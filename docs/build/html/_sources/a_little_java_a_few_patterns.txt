=======================================
 《A Little Java, A Few Patterns》笔记
=======================================
:tags: java, oop, design pattern, functional
:category: java

.. contents::

----------------------------------------

Java小用
========
下面是一些有关Java体验的提示：

1. 在一个文件中给出类的完整层次。

2. 对于每个命名不以上标D、V、I、M结尾的类，\
   添加 `toString` 方法，并遵守以下规则：

   a) 如果一个类没有属性

      .. code-block:: java

         public String toString() {
             return "new " + getClass().getName() + "()";
         }

   b) 如果一个类只有一个属性，比如叫 `x`

      .. code-block:: java

         public String toString() {
             return "new " + getClass().getName() + "(" + x + ")";
         }

   c) 如果一个类有两个属性，比如叫 `x` 和 `y`

      .. code-block:: java

         public String toString() {
             return "new " + getClass().getName() + "(" + x + ", " + y + ")";
         }

3. 在文件的底部添加如下类：

   .. code-block:: java

      class Main {
          public static void main(String args[]) {
              DataType_or_Interface y = new ______;
              System.out.println( ... ... );
          }
      }

`DataType_or_Interface y = new ______;` 是用来创建你想尝试的对象。

`System.out.println( ... ... );` 是用来填写你想尝试的表达式。

比如，你想尝试第2章定义的 `ManhattanPt` 的 `distanceTo0` 方法，\
你就可以添加如下代码到你文件的最后：

.. code-block:: java

   public class Main{
       public static void main(String args[]) {
           PointD y = new ManhattanPt(2, 8);
           System.out.println(y.distanceTo0());
       }
   }

如果你想尝试多条表达式，就修改 `y` ，就像第10章里，
::

   y._ _ _ _ _ _;
   y._ _ _ _ _ _;
   y._ _ _ _ _ _

替换成
::

   y._ _ _ _ _ _ + "\n" +
   y._ _ _ _ _ _ + "\n" +
   y._ _ _ _ _ _

如果你想尝试第10章中定义的 `PiemanM` 的多个方法，\
那么你就将以下代码写在文件的最后面：

.. code-block:: java

   class Main {
       public static void main(String args[]) {
           PiemanI y = new PiemanM();
           System.out.println(
               y.addTop(new Anchovy()) + "\n" +
               y.addTop(new Anchovy()) + "\n" +
               y.substTop(new Tuna(), new Anchovy())
           );
       }
   }

4. 最后，编译文件并且执行 `Main` 类。

   .. tip::

      按照上面的要求，保存的代码的文件名同时也要为 `Main.java` 。\
      (因为Java会根据文件名来查找其文件内同名的类，再执行该类的main方法)

      然后使用 `javac Main.java` 来进行编译生成 `Main.class` 中间码文件。

      最后， `java Main` 来执行程序。

      建议大家上网搜索一下 `Java helloworld` 看一下相关教程就可以了。\
      暂时不用深入学习 `Java` 。

Modern Toys
===========
这一章节，作者通过一系列的对话，\
让读者了解到Java中基本类型（只介绍了int, boolean类型），\
然后引申到如何使用Java自定义类型。

类型是什么？
::

   A type is a name for a collection of values

SeasoningD
----------
自定义 `SeasoningD` 类型，以其它的四个子类型。

.. code-block:: java

   abstract class SeasoningD{} //调味品

   class Salt extends SeasoningD{} //盐

   class Pepper extends SeasoningD{} //胡椒粉

   class Thyme extends SeasoningD{} //百里香

   class Sage extends SeasoningD{} //鼠尾草

虽然四个子类型没有定义 `构造函数` ，\
但是Java会自动添加一个默认的构造函数。

PointD
------
再自定义个 `PointD` 类型，和它的两个子类型。

.. code-block:: java

   abstract class PointD{} //坐标

   class CartesianPt extends PointD{ //笛卡尔坐标
       int x;
       int y;
       CartesianPt(int _x, int _y){
           x = _x;
           y = _y;
       }
   }

   class ManhattanPt extends PointD{ //曼哈顿坐标
       int x;
       int y;
       ManhattanPt(int _x, int _y){
           x = _x;
           y = _y;
       }
   }

PointD的两个子类型就手动添加了构造函数，\
因为它们需要有额外的属性传入构造函数。

当使用 `new` 关键字时， \
Java会通过调用类的构造函数来生成其对应的实例。

对抽象类直接使用 `new` 关键字是不行的，\
因为抽象类是一个未完全定义的类，无法实例化。

NumD
----
再定义个 `NumD` 类型，和它的两个子类型。

.. code-block:: java

   abstract class NumD{}

   class Zero extends NumD{}

   class OneMoreThan extends NumD{
       NumD predecessor;
       OneMoreThan(NumD _d){
           predecessor = _d;
       }
   }

使用这两个子类型，就可以表示一个整数系统。

1. `Zero` 表示 `0` 

2. `new OneMoreThan(new Zero())` 表示 `1`

3. `new OneMoreThan(new OneMoreThan(new Zero()))` 表示 `2`

4. ... ...

.. tip::

   上面的概念其实就是 `Church encoding`_ 

`abstract` 、 `class` 、 `extends` 各代表什么？
::

  `abstract` 定义类型

  `class` 定义子类型

  `extends` 将以上两者联系起来

**第一条建议**

  When specifying a collection of data,

  use *abstract* classes for datatypes and

  *extended* classes for variants.

LayerD
------
.. code-block:: java

   abstract class LayerD{}

   class Base extends LayerD{
       Object o;
       Base(Object _o){
           o = _o;
       }
   }

   class Slice extends LayerD{
       LayerD l;
       Slice(LayerD _l){
           l = _l;
       }
   }

书中通过一系列对话和示例来揭示\
自定义类型与Java提供的基本类型的不同之处，\
给读者一个基本印象：基本类型不能直接作用于自定义类型，\
而是将之先转换为类似自定义类型的形式，然后才能使用。

接下来的章节会其进行进一步的揭示。

.. tip::

   Java不能说是完全的面向对象。为了性能考虑，Java的基本类型并非对象。

   如果需要将之转换为对象，需要使用Java提供的包装类才行。

   如果想深入了解：请Google `Java 基本类型 引用类型`

Methods to Our Madness
======================
上一章讲解了如何在Java中的定义类型。

这一章主要讲如何向这些类型添加方法。

PointD
------
.. code-block:: java

   abstract class PointD{
       abstract int distanceTo0();
   }

   class CartesianPt extends PointD{ //笛卡尔坐标
       int x;
       int y;
       CartesianPt(int _x, int _y){
           x = _x;
           y = _y;
       }
       int distanceTo0(){
           return (int)Math.sqrt(x * x + y * y);
       }
   }

   class ManhattanPt extends PointD{ //曼哈顿坐标
       int x;
       int y;
       ManhattanPt(int _x, int _y){
           x = _x;
           y = _y;
       }
       int distanceTo0(){
           return x + y;
       }
   }

当子类型（具体类）从类型（抽象类）继承时，\
需要同时实现抽象类中的抽象方法。

ShishD
------
.. code-block:: java

   // 书上的例子中各个类一层层的套在一起，可以理解成一个烤串
   abstract class ShishD { //羊肉串
       abstract boolean onlyOnions(); //烤串上是不是只有洋葱
       abstract boolean isVegetarian(); //烤串上是不是全是蔬菜
   }

   class Skewer extends ShishD { //串，烤肉叉子
       boolean onlyOnions(){
           return true;
       }

       boolean isVegetarian(){
           return true;
       }
   }

   class Onion extends ShishD { //洋葱
       ShishD s;
       Onion(ShishD _s) {
           s = _s;
       }

       boolean onlyOnions(){
           return s.onlyOnions();
       }

       boolean isVegetarian(){
           return s.isVegetarian();
       }
   }

   class Lamb extends ShishD { //羔羊肉
       ShishD s;
       Lamb(ShishD _s) {
           s = _s;
       }

       boolean onlyOnions(){
           return false;
       }

       boolean isVegetarian(){
           return false;
       }
   }

   class Tomato extends ShishD { //西红柿
       ShishD s;
       Tomato(ShishD _s) {
           s = _s;
       }

       boolean onlyOnions(){
           return false;
       }

       boolean isVegetarian(){
           return s.isVegetarian();
       }
   }

**第二条建议**

  When writing a function over a datatype,

  place a method in each of the variants that make up the datatype.

  If a field of a variant belongs to the same datatype,

  the method may call the corresponding method of the field in

  computing the function.

KebabD
------
.. code-block:: java

   abstract class KebabD { //烤肉
       abstract boolean isVeggie(); //是否以纯蔬菜为辅料的烤肉
       abstract Object whatHolder(); //烤肉的摆放工具是什么
   }

   class Holder extends KebabD { //烤肉摆放工具（意译）
       Object o;
       Holder (Object _o) {
           o = _o;
       }
       boolean isVeggie(){
           return true;
       }
       Object whatHolder(){
           return o;
       }
   }

   class Shallot extends KebabD { //葱
       KebabD k;
       Shallot(KebabD _k) {
           k = _k;
       }
       boolean isVeggie(){
           return k.isVeggie();
       }
       Object whatHolder(){
           return k.whatHolder();
       }
   }

   class Shrimp extends KebabD { //小虾
       KebabD k;
       Shrimp(KebabD _k) {
           k = _k;
       }
       boolean isVeggie(){
           return false;
       }
       Object whatHolder(){
           return k.whatHolder();
       }
   }

   class Radish extends KebabD { //萝卜
       KebabD k;
       Radish(KebabD _k) {
           k = _k;
       }
       boolean isVeggie(){
           return k.isVeggie();
       }
       Object whatHolder(){
           return k.whatHolder();
       }
   }

   class Pepper extends KebabD { //胡椒粉
       KebabD k;
       Pepper(KebabD _k) {
           k = _k;
       }
       boolean isVeggie(){
           return k.isVeggie();
       }
       Object whatHolder(){
           return k.whatHolder();
       }
   }

   class Zucchini extends KebabD { //西葫芦
       KebabD k;
       Zucchini(KebabD _k) {
           k = _k;
       }
       boolean isVeggie(){
           return k.isVeggie();
       }
       Object whatHolder(){
           return k.whatHolder();
       }
   }

定义一下烤肉摆放的工具。

大致分成两种:

* 一种是将烤肉串起来的工具

  .. code-block:: java
  
     abstract class RodD{} //杆，用于将烤肉串起来
  
     class Dagger extends RodD{} //匕首
  
     class Sabre extends RodD{} //军刀
  
     class Sword extends RodD{} //剑
  
* 一种将烤肉平铺的工具。

  .. code-block:: java
  
     abstract class PlateD{} //盘子
  
     class Gold extends PlateD{} //金盘子
  
     class Silver extends PlateD{} //银盘子
  
     class Brass extends PlateD{} //黄铜盘子
  
     class Copper extends PlateD{} //镀铜盘子
  
     class Wood extends PlateD{} //木盘子

PointD
------
.. code-block:: java

   abstract class PointD{
       abstract int distanceTo0();
   }

   class CartesianPt extends PointD{ //笛卡尔坐标
       int x;
       int y;
       CartesianPt(int _x, int _y){
           x = _x;
           y = _y;
       }
       int distanceTo0(){
           return (int)Math.sqrt(x * x + y * y);
       }
       boolean closerTo0(CartesianPt p){
           return distanceTo0() <= p.distanceTo0();
       }
   }

   class ManhattanPt extends PointD{ //曼哈顿坐标
       int x;
       int y;
       ManhattanPt(int _x, int _y){
           x = _x;
           y = _y;
       }
       int distanceTo0(){
           return x + y;
       }
       boolean closerTo0(ManhattanPt p){
           return distanceTo0() <= p.distanceTo0();
       }
   }

抽取变体类型中公共的部分到抽象类型中。

.. code-block:: java

   abstract class PointD{
       int x;
       int y;
       PointD(int _x, int _y){
           x = _x;
           y = _y;
       }
       abstract int distanceTo0();
       boolean closerTo0(PointD p){
           return distanceTo0() <= p.distanceTo0();
       }
   }

   class CartesianPt extends PointD{ //笛卡尔坐标
       CartesianPt(int _x, int _y){
           super(_x, _y);
       }
       int distanceTo0(){
           return (int)Math.sqrt(x * x + y * y);
       }
   }

   class ManhattanPt extends PointD{ //曼哈顿坐标
       ManhattanPt(int _x, int _y){
           super(_x, _y);
       }
       int distanceTo0(){
           return x + y;
       }
   }

What's New?
===========
PizzaD
------
.. code-block:: java

   abstract class PizzaD { //比萨饼
       abstract PizzaD remA(); //去除比萨饼中的凤尾鱼顶料(因为太咸了)
       abstract PizzaD topAwC(); //在凤尾鱼顶料上加上奶酪顶料(这样会盖住凤尾鱼的咸味)
       abstract PizzaD subAbC(); //将所有的凤尾鱼顶料换成奶酪顶料
   }

   class Crust extends PizzaD { //面包皮
       PizzaD subAbC(){
           return new Crust();
       }
       PizzaD topAwC(){
           return new Crust();
       }
       PizzaD subAbC(){
           return new Crust();
       }
   }

   // 下面是各种顶料
   class Cheese extends PizzaD { //奶酪
       PizzaD p;
       Cheese (PizzaD _p) {
           p = _p;
       }
       PizzaD remA(){
           return new Cheese(p.remA());
       }
       PizzaD topAwC(){
           return new Cheese(p.topAwC());
       }
       PizzaD subAbC(){
           return new Cheese(p.subAbC());
       }
   }

   class Olive extends PizzaD { //橄榄
       PizzaD p;
       Olive (PizzaD _p) {
           p = _p;
       }
       PizzaD remA(){
           return new Olive(p.remA());
       }
       PizzaD topAwC(){
           return new Olive(p.topAwC());
       }
       PizzaD subAbC(){
           return new Olive(p.subAbC());
       }
   }

   class Anchovy extends PizzaD { //凤尾鱼
       PizzaD p;
       Anchovy (PizzaD _p) {
           p = _p;
       }
       PizzaD remA(){
           return p.remA();
       }
       PizzaD topAwC(){
           return new Cheese(new Anchovy(p.topAwC()));
       }
       PizzaD subAbC(){
           return new Cheese(p.subAbC());
       }
   }

   class Sausage extends PizzaD { //香肠
       PizzaD p;
       Sausage (PizzaD _p) {
           p = _p;
       }
       PizzaD remA(){
           return new Sausage(p.remA());
       }
       PizzaD topAwC(){
           return new Sausage(p.topAwC());
       }
       PizzaD subAbC(){
           return new Sausage(p.subAbC());
       }
   }

如果想要在比萨饼上面添加额外的顶料怎么办？

很简单，再从 `PizzaD` 扩展出一个新的子类型就可以了。

.. code-block:: java

   class Spinach extends PizzaD { //菠菜
       PizzaD p;
       Spinach (PizzaD _p) {
           p = _p;
       }
       PizzaD remA(){
           return new Spinach(p.remA());
       }
       PizzaD topAwC(){
           return new Spinach(p.topAwC());
       }
       PizzaD subAbC(){
           return new Spinach(p.subAbC());
       }
   }

但是每添加一个新的变体类型都要加上三个方法，好累的说。

有什么比较好的办法解决这个问题呢？

  下一章节给你答案。

**第三条建议**

  When writing a function that returns values of a datatype,

  use *new* to create these values.

Come to Our Carousel
====================
这一章节就针对上一章节暴露的问题，提出解决方法：

  **访问者模式**

不过作者没有一上来就给出完美的实现，它是通过一步步来引导的。

下面的两个例子只是第一步：
::

   先将类似的方法聚合到访问者类中

ShishD
------
.. code-block:: java

   // 访问者
   class OnlyOnionsV {
       boolean forSkewer() {
           return true;
       }
       boolean forOnion(ShishD s) {
           return s.onlyOnions();
       }
       boolean forLamb(ShishD s) {
           return false;
       }
       boolean forTomato(ShishD s) {
           return false;
       }
   }

   class IsVegetarianV {
       boolean forSkewer() {
           return ture;
       }
       boolean forOnion(ShishD s) {
           return s.IsVegetarian();
       }
       boolean forLamb(ShishD s) {
           return false;
       }
       boolean forTomato(ShishD s) {
           return s.IsVegetarian();
       }
   }

.. code-block:: java

   // 使用访问者模式的ShishD
   // 这里可以对比一下第二章节的ShishD代码
   abstract class ShishD { //羊肉
       OnlyOnionsV ooFn = new OnlyOnionsV();
       IsVegetarianV ivFn = new IsVegetarianV();
       abstract boolean onlyOnions();
       abstract boolean IsVegetarian();
   }

   class Skewer extends ShishD { //串
       boolean onlyOnions() {
           return ooFn.forSkewer();
       }
       boolean IsVegetarian() {
           return ivFn.forSkewer();
       }
   }

   class Onion extends ShishD { //洋葱
       ShishD s;
       Onion (ShishD _s) {
           s = _s;
       }
       boolean onlyOnions() {
           return ooFn.forOnion(s);
       }
       boolean IsVegetarian() {
           return ivFn.forOnion(s);
       }
   }

   class Lamb extends ShishD { //羔羊肉
       ShishD s;
       Lamb (ShishD _s) {
           s = _s;
       }
       boolean onlyLambs() {
           return ooFn.forLamb(s);
       }
       boolean IsVegetarian() {
           return ivFn.forLamb(s);
       }
   }

   class Tomato extends ShishD { //西红柿
       ShishD s;
       Tomato (ShishD _s) {
           s = _s;
       }
       boolean onlyTomatos() {
           return ooFn.forTomato(s);
       }
       boolean IsVegetarian() {
           return ivFn.forTomato(s);
       }
   }

**第四条建议**

  When writing several functions for the

  same self-referential datatype, use

  visitor protocols so that all methods for

  a function can be found in a single class.

PizzaD
------
.. code-block:: java

   abstract class PizzaD { //披萨饼
       RemAV remFn = new RemAV();
       TopAwCV topFn = new TopAwCV();
       SubAbCV subFn = new SubAbCV();
       abstract PizzaD remA();
       abstract PizzaD topAwC();
       abstract PizzaD subAbC();
   }

   class Crust extends PizzaD { //面包皮
       PizzaD remA() {
           return remFn.forCrust();
       }
       PizzaD topAwC() {
           return topFn.forCrust();
       }
       PizzaD subAbC() {
           return subFn.forCrust();
       }
   }

   class Cheese extends PizzaD { //奶酪
       PizzaD p;
       Cheese(PizzaD _p) {
           p = _p;
       }
       PizzaD remA() {
           return remFn.forCheese(p);
       }
       PizzaD topAwC() {
           return topFn.forCheese(p);
       }
       PizzaD subAbC() {
           return subFn.forCheese(p);
       }

   }

   Classr Olive extends PizzaD { //橄榄
       PizzaD p;
       Olive(PizzaD _p) {
           p = _p;
       }
       PizzaD remA() {
           return remFn.forOlive(p);
       }
       PizzaD topAwC() {
           return topFn.forOlive(p);
       }
       PizzaD subAbC() {
           return subFn.forOlive(p);
       }
   }

   class Anchovy extends PizzaD { //凤尾鱼
       PizzaD p;
       Anchovy(PizzaD _p) {
           p = _p;
       }
       PizzaD remA() {
           return remFn.forAnchovy(p);
       }
       PizzaD topAwC() {
           return topFn.forAnchovy(p);
       }
       PizzaD subAbC() {
           return subFn.forAnchovy(p);
       }
   }

   class Sausage extends PizzaD { //香肠
       PizzaD p;
       Sausage(PizzaD _p) {
           p = _p;
       }
       PizzaD remA() {
           return remFn.forSausage(p);
       }
       PizzaD topAwC() {
           return topFn.forSausage(p);
       }
       PizzaD subAbC() {
           return subFn.forSausage(p);
       }
   }

.. code-block:: java

   class RemAV {
       PizzaD forCrust() {
           return new Crust();
       }
       PizzaD forCheese(PizzaD p) {
           return new Cheese(p.remA());
       }
       PizzaD forOlive(PizzaD p) {
           return new Olive(p.remA());
       }
       PizzaD forAnchovy(PizzaD p) {
           return p.remA();
       }
       PizzaD forSausage(PizzaD p) {
           return new Sausage(p.remA());
       }
   }

   class TopAwCV {
       PizzaD forCrust() {
           return new Crust();
       }
       PizzaD forCheese(PizzaD p) {
           return new Cheese(p.topAwC());
       }
       PizzaD forOlive(PizzaD p) {
           return new Olive(p.topAwC());
       }
       PizzaD forAnchovy(PizzaD p) {
           return new Cheese(new Anchovy(p.topAwC()));
       }
       PizzaD forSausage(PizzaD p) {
           return new Sausage(p.topAwC());
       }
   }

   class SubAbCV {
       PizzaD forCrust() {
           return new Crust();
       }
       PizzaD forCheese(PizzaD p) {
           return new Cheese(p.subAbC());
       }
       PizzaD forOlive(PizzaD p) {
           return new Olive(p.subAbC());
       }
       PizzaD forAnchovy(PizzaD p) {
           return new Cheese(p.subAbC());
       }
       PizzaD forSausage(PizzaD p) {
           return new Sausage(p.subAbC());
       }
   }

Objects Are People, Too
=======================
PieD
----
.. code-block:: java

   abstract class PieD { //馅饼，派
       RemAV raFn = new RemAV();
       RemFishV rfFn = new RemFishV();
       abstract PieD remA();
       abstract PieD remFish(FishD f);
   }

   class Bot extends PieD { //底料
       PieD remA() {
           return raFn.forBot();
       }
       Pied remFish(FishD f) {
           return rfFn.forBot(f);
       }
   }

   class Top extends PieD { //顶料
       Object t;
       PieD r;
       Top(Object _t, PieD _r) {
           t = _t,
           r = _r,
       }
       PieD remA() {
           return raFn.forTop(t, r);
       }
       PieD remFish(FishD f) {
           return rfFn.forTop(t, r, f);
       }
   }

FishD
-----
.. code-block:: java

   abstract class FishD {}

   class Anchovy extends FishD { //凤尾鱼
       public boolean equals(Object o) {
           return (o instanceof Anchovy);
       }
   }

   class Salmon extends FishD { //鲑鱼
       public boolean equals(Object o) {
           return (o instanceof Salmon);
       }
   }

   class Tuna extends FishD { //金枪鱼
       public boolean equals(Object o) {
           return (o instanceof Tuna);
       }
   }

.. code-block:: java

   // 删除凤尾鱼的方法
   class RemAV {
       PieD forBot() {
           return new Bot();
       }
       PieD forTop(Object t, PieD r) {
           if (new Anchovy().equals(t))
               return r.remA();
           else
               return new Top(t, r.remA());
       }
   }

   // 删除指定鱼的方法，相当在 `RemAV` 的概念上再抽象一层
   class RemFishV {
       PieD forBot(FishD f) {
           return new Bot();
       }
       PieD forTop(Object t, PieD r, FishD f) {
           if (f.equals(t))
               return r.remFish(f);
           else
               return new Top(t, r.remFish(f));
       }
   }

   // 删除指定整数的方法
   class RemIntV {
       PieD forBot(Integer i) {
           return new Bot();
       }
       PieD forTop(Object t, PieD r, Integer i) {
           if (i.equals(t))
               return r.remInt(i);
           else
               return new Top(t, r.remInt(i));
       }
   }

`RemFishV` 和  `RemIntV` 的整个逻辑很类似么，那么将它们重新抽象一下？

.. code-block:: java

   class RemV {
       PieD forBot(Object o) {
           return new Bot();
       }
       PieD forTop(Object t, PieD r, Object o) {
           if (o.equals(t))
               return r.rem(o);
           else
               return new Top(t, r.rem(o));
       }
   }

`PieD` 及它的变种类型 `Bot`  `Top` 也要简单变化一下。

.. code-block:: java

   abstract class PieD {
       RemV remFn = new RemV();
       abstract PieD rem(Object o);
   }

   class Bot extends PieD {
       PieD rem(Object o){
           return remFn.forBot(o);
       }
   }

   class Top extends PieD {
       Object t;
       PieD r;
       Top(Object _t, PieD _r){
           t = _t;
           r = _r;
       }
       PieD rem(Object o){
           return remFn.forTop(t, r, o);
       }
    }

现在的 `Bot`  `Top` 在调用rem时，\
即可以传入 `FishD` 也可以传入 `Integer` 了。

NumD
----
.. code-block:: java

   abstract class NumD {}

   class OneMoreThan extends NumD {
       NumD predecessor;
       OneMoreThan(NumD _p) {
           predecessor = _p;
       }
       public boolean equals(Object o) {
           if (o instanceof OneMoreThan)
               return predecessor.equals(
                   ((OneMoreThan)o).predecessor
               ),
           else
               return false;
       }
   }

   class Zero extends NumD {
       public boolean equals(Object o) {
           return (o instanceof Zero);
       }
   }

.. code-block:: java

   class SubstFishV {
       PieD forBot(FishD n, FishD o) {
           return new Bot();
       }
       PieD forTop (Object t, PieD r, FishD n, FishD o) {
           if (o.equals(t))
               return new Top(n, r.substFish(n, o));
           else
               return new Top(t, r.substFish(n, 0));
       }
   }

   class SubstIntV {
       PieD forBot(Integer n, Integer o) {
           return new Bot();
       }
       PieD forTop (Object t, PieD r, Integer n, Integer o) {
           if (o.equals(t))
               return new Top(n, r.substInt(n, o));
           else
               return new Top(t, r.substInt(n, 0));
       }
   }

   class SubstV {
       PieD forBot(Object n, Object o) {
           return new Bot();
       }
       PieD forTop (Object t, PieD r, Object n, Object o) {
           if (o.equals(t))
               return new Top(n, r.subst(n, o));
           else
               return new Top(t, r.subst(n, 0));
       }
   }

`SubstV` 和  `RemV` 的做法是一样。

再整理一下 `PieD` 

.. code-block:: java

   abstract class PieD {
       RemV remFn = new RemV();
       SubsbV substFn = new SubstV();
       abstract PieD rem(Object o);
       abstract PieD subst(Object n, Object o);
   }

   class Bot extends PieD {
       PieD rem(Object o){
           return remFn.forBot(o);
       }
       PieD subst(Object n, Object o){
           return substFn.forBot(n, o)
       }
   }

   class Top extends PieD {
       Object t;
       PieD r;
       Top(Object _t, PieD _r){
           t = _t;
           r = _r;
       }
       PieD rem(Object o){
           return remFn.forTop(t, r, o);
       }
       PieD subst(Object n, Object o){
           return substFn.forTop(n, o)
       }
   }

Boring Protocols
================
之前5章看起来还真是 `Boring` 。

这一章的名称中虽然有 `Boring` ，但是内容却是很有趣的。

.. tip::

   这里的 `Protocols` 我觉得应该指的是 `Interface` 的意思。

----------------------------------------

本章接着上一章节的最后代码继续讲解。

这次将 `remFn`  `substFn` 放入到参数的位置。

.. code-block:: java

   abstract class PieD {
       abstract PieD rem(RemV remFn, Object o);
       abstract PieD subst(SubstV substFn, Object n, Object o);
   }

   class Top extends PieD {
       Object t;
       PieD r;
       Top(Object _t, PieD _r) {
           t = _t;
           r = _r;
       }
       PieD rem(RemV remFn, Object o) {
           return remFn.forTop(t, r, o);
       }
       PieD subst(SubstV substFn, Object n, Object o) {
           return sbustFn.forTop(t, r, n, o);
       }
   }

   class Bot extends PieD {
       Object t;
       PieD r;
       Bot(Object _t, PieD _r) {
           t = _t;
           r = _r;
       }
       PieD rem(RemV remFn, Object o) {
           return remFn.forBot(t, r, o);
       }
       PieD subst(SubstV substFn, Object n, Object o) {
           return sbustFn.forBot(t, r, n, o);
       }
   }

同步修改对应的访问者类。

.. code-block:: java

   class RemV {
       PieD forBot(Object o){
           return new Bot();
       }
       PieD forTop(Object t, PieD r, Object o){
           if (o.equals(t))
               return r.rem(this, o);
           else
               return new Top(t, r.rem(this, o));
       }
   }

   class SubstV {
       PieD forBot(Object n, Object o){
           return new Bot();
       }
       PieD forTop(Object t, PieD r, Object n, Object o){
           if (o.equals(t))
               return new Top(n, r.subst(this, n, o));
           else
               return new Top(t, r.subst(this, n, o));
       }
   }

再修改访问者类，将更多的参数传入到访问者类中。

.. code-block:: java

   class RemV {
       Object o;
       RemV(Object _o) {
           o = _o;
       }
       PieD forBot(Object o){
           return new Bot();
       }
       PieD forTop(Object t, PieD r){
           if (o.equals(t))
               return r.rem(this);
           else
               return new Top(t, r.rem(this));
       }
   }

   class SubstV {
       Object n;
       Object o;
       SubstV(Object _n, Object _o){
           n = _n;
           o = _o;
       }

       PieD forBot(Object n, Object o){
           return new Bot();
       }
       PieD forTop(Object t, PieD r){
           if (o.equals(t))
               return new Top(n, r.subst(this));
           else
               return new Top(t, r.subst(this));
       }
   }

上面的形式就有点函数式编程里面的 **闭包** 的意味了。

好了，根据上面修改后的 `SubstV` ，重新修改一下 `PieD` 及其 `Bot` 和 `Top`

.. code-block:: java

   abstract class PieD {
       abstract PieD rem(RemV remFn);
       abstract PieD subst(SubstV substFn);
   }

   class Top extends PieD {
       Object t;
       PieD r;
       Top(Object _t, PieD _r) {
           t = _t;
           r = _r;
       }
       PieD rem(RemV remFn) {
           return remFn.forTop(t, r);
       }
       PieD subst(SubstV substFn) {
           return sbustFn.forTop(t, r);
       }
   }

   class Bot extends PieD {
       Object t;
       PieD r;
       Bot(Object _t, PieD _r) {
           t = _t;
           r = _r;
       }
       PieD rem(RemV remFn) {
           return remFn.forBot();
       }
       PieD subst(SubstV substFn) {
           return sbustFn.forBot();
       }
   }

在 `Top` 和 `Bot` 类中， `rem` 和 `subst` 的代码都很类似，

所以我们可以进一步抽象。

.. warning::

   前方高能预警，高潮就要到来了。

.. code-block:: java

   // abstract class PieVisitorD {
   //     abstract PieD forBot();
   //     abstract PieD forTop(Object t, PieD r);
   // }

   interface PieVisitorI {
       PieD forBot();
       PieD forTop(Object t, PieD r);
   }

   class RemV implements PieVisitorI {
       Object o;
       RemV(Object _o) {
           o = _o;
       }
       public PieD forBot() {
           return new Bot();
       }
       public PieD forTop(Object t, PieD r) {
           if (o.equals(t))
               return r.accept(this);
           else
               return new Top(t, r.accept(this));
       }
   }

   class SbustV implements PieVisitorI {
       Object n;
       Object o;
       SubstV(Object _n, Object _o) {
           n = _n;
           o = _o;
       }
       public PieD forBot() {
           return new Bot();
       }
       public PieD fotTop(Object t, PieD r) {
           if (o.equals(t))
               return new Top(n, r.accept(this));
           else
               return new Top(t, r.accept(this));
       }
   }

同步修改 `PieD`

.. code-block:: java

   abstract class PieD {
       abstract PieD accept(PieVisitorI ask);
   }

   class Bot extends PieD {
       PieD accept(PieVisitorI ask) {
           return ask.forBot();
       }
   }

   class Top extends PieD {
       Object t;
       PieD r;
       Top(Object _t, PieD _r) {
           t = _t;
           r = _r;
       }
       PieD accept(PieVisitorI ask) {
           return ask.forTop(t, r);
       }
   }

.. code-block:: java

   // 有限制次数的替换
   class LtdSubstV implements PieVisitorI {
       int c;
       Object n;
       Object o;
       LtdSubstV(int _c, Object _n, Object _o) {
           c = _c;
           n = _n;
           o = _o;
       }
       public PieD forBot() {
           return new Bot();
       }
       public PieD forTop(Object t, PieD r) {
           if (c == 0)
               return new Top(t, r);
           else
               if (o.equals(t))
                   return new Top(n, r.accept(LtdSubstV(c-1, n, o)));
               else
                   return new Top(t, r.accept(this));
       }
   }

.. tip::

   **第六条建议**

   When the additional consumed values

   change for a self-referenced use of a

   visitor, don't forget to create a new visitor.

Oh My!
======

.. code-block:: java

   abstract class FruitD {} // 水果

   class Peach extends FruitD {  //桃
       public boolean equals(Object o) {
           return (o instanceof Peach);
       }
   }

   class Apple extends FruitD { //苹果
       public boolean equals(Object o) {
           return (o instanceof Apple);
       }
   }

   class Pear extends FruitD { //梨
       public boolean equals(Object o) {
           return (o instanceof Pear);
       }
   }

   class Lemon extends FruitD { //柠檬
       public boolean equals(Object o) {
           return (o instanceof Lemon);
       }
   }

   class Fig extends FruitD { //无花果
       public boolean equals(Object o) {
           return (o instanceof Fig);
       }
   }

.. code-block:: java

   abstract class TreeD { //树
       abstract boolean accept(bTreeVisitorI ask);
       abstract int accept(iTreeVisitorI ask);
       abstract TreeD accept(tTreeVisitorI ask);
   }

   class Bud extends TreeD { //芽
       boolean accept(bTreeVisitorI ask) {
           return ask.forBud();
       }
       int accept(iTreeVisitorI ask) {
           return ask.forBud();
       }
       TreeD accept(tTreeVisitorI ask) {
           return ask.forBud();
       }
   }

   class Flat extends TreeD { //平顶
       FruitD f;
       TreeD t;
       Flat(FruitD _f, TreeD _t) {
           f = _f;
           t = _t;
       }
       boolean accept(bTreeVisitorI ask) {
           return ask.forFlat(f, t);
       }
       int accept(iTreeVisitorI ask) {
           return ask.forFlat(f, t);
       }
       TreeD accept(tTreeVisitorI ask) {
           return ask.forFlat(f, t);
       }
   }

   class Split extends TreeD { //分枝
       TreeD l;
       TreeD r;
       Split(Treed _l, TreeD _r) {
           l = _l;
           r = _r;
       }
       boolean accept(bTreeVisitorI ask) {
           return ask.forSplit(l, r);
       }
       int accept(iTreeVisitorI ask) {
           return ask.forSplit(l, r);
       }
       TreeD accept(tTreeVisitorI ask) {
           return ask.forFlat(l, r);
       }
   }
   
.. code-block:: java

   interface bTreeVisitorI {
       boolean forBud();
       boolean forFlat(FruitD f, TreeD t);
       boolean forSplit(TreeD l, TreeD r);
   }

   class bIsFlatV implements bTreeVisitorI {
       public boolean forBud() {
           return true;
       }
       public boolean forFlat(FruitD f, TreeD t) {
           return t.accept(this);
       }
       public boolean forSplit(TreeD l, TreeD r) {
           return false;
       }
   }

   class bIsSplitV implements bTreeVisitorI {
       public boolean forBud() {
           return true;
       }
       public boolean forFlat(FruitD f, TreeD t) {
           return false;
       }
       public boolean forSplit(TreeD l, TreeD r) {
           return l.accept(this) && r.accept(this);
       }
   }

   class bHasFruitV implements bTreeVisitorI {
       public boolean forBud() {
           return false;
       }
       public boolean forFlat(FruitD f, TreeD t) {
           return true;
       }
       public boolean forSplit(TreeD l, TreeD r) {
           return l.accept(this) || r.accept(this);
       }
   }

.. code-block:: java

   interface iTreeVisitorI {
       int forBud();
       int forFlat(FruitD f, TreeD t);
       int forSplit(TreeD l, TreeD r);
   }

   class iHeightV implements iTreeVisitorI {
       public int forBud() {
           return 0;
       }
       public int forFlat(FruitD f, TreeD t) {
           return t.accept(this) + 1;
       }
       public int forSplit(TreeD l, TreeD r) {
           return (l.accept(this) |_| r.accept(this)) + 1;
       }
   }

   class iOccursV implements iTreeVisitorI {
       FruitD a;
       iOccursV(FruitD _a) {
           a = _a;
       }
       public int forBud() {
           return 0;
       }
       public int forFlat(FruitD f, TreeD t) {
           if (f.equals(a))
               return t.accept(this) + 1;
           else
               return t.accept(this);
       }
       public int forSplit(TreeD l, TreeD r) {
           return l.accept(this) + r.accept(this);
       }
   }

.. code-block:: java

   interface tTreeVisitorI {
       TreeD forBud();
       TreeD forFlat(FruitD f, TreeD t);
       TreeD forSplit(TreeD l, TreeD r);
   }

   class tSubstV implements tTreeVisitorI {
       FruitD n;
       FruitD o;
       tSubstV(FruitD _n, FruitD _o) {
           n = _n;
           o = _o;
       }
       public TreeD forBud() {
           return new Bud();
       }
       public TreeD forFlat(FruitD f, TreeD t) {
           if (o.equals(f))
               return new Flat(n, t.accept(this));
           else
               return new Flat(f, t.accept(this));
       }
       public TreeD forSplit(TreeD l, TreeD r) {
           return new Split(l.accept(this), r.accept(this));
       }
   }

上面的三个接口是不是有点繁琐？那么将它合并起来。

.. code-block:: java

   interface TreeVisitorI {
       Object forBud();
       Object forFlat(FruitD f, TreeD t);
       Object forSplit(TreeD l, TreeD r);
   }

   abstract class TreeD {
       abstract Object accept(TreeVisitorI ask);
   }

   class Bud extends TreeD {
       Object accept(TreeVisitorI ask) {
           return ask.forBud();
       }
   }

   class Flat extends TreeD {
       FruitD f;
       TreeD t;
       Flat(FruitD _f, TreeD _t) {
           f = _f;
           t = _t;
       }
       Object accept(TreeVisitorI ask) {
           return ask.forFlat(f, t);
       }
   }

   class Split extends TreeD {
       TreeD l;
       TreeD r;
       Split(Treed _l, TreeD _r) {
           l = _l;
           r = _r;
       }
       Object accept(TreeVisitorI ask) {
           return ask.forSplit(l, r);
       }
   }

   class IsFlatV implements TreeVisitorI {
       public Object forBud() {
           return new Boolean(true);
       }
       public Object forFlat(FruitD f, TreeD t) {
           return t.accept(this);
       }
       public Object forSplit(TreeD l, TreeD r) {
           return new Boolean(false);
       }
   }

   class bIsSplitV implements bTreeVisitorI {
       public boolean forBud() {
           return new Boolean(true);
       }
       public boolean forFlat(FruitD f, TreeD t) {
           return new Boolean(false);
       }
       public boolean forSplit(TreeD l, TreeD r) {
           if (((Boolean)(l.accept(this))).booleanValue())
               return r.accept(this);
           else:
               return new Boolean(false);
       }
   }

.. tip::
   
   **第七条建议**

   When designing visitor protocols for

   many different types, create a unifying

   protocol using `Object` .

但是这有一个不好的地方，如果返回的是Java的内置类型，

那内部在进行处理时，就要先进行转换，有时候甚至要令人发指的程度。

比如下面的代码：

.. code-block:: java

   class OccursV implements TreeVisitorI {
       FruitD a;
       iOccursV(FruitD _a) {
           a = _a;
       }
       public Object forBud() {
           return new Integer(0);
       }
       public Object forFlat(FruitD f, TreeD t) {
           if (f.equals(a))
               return new Integer(((Integer)(t.accept(this))).intValue() + 1);
           else
               return t.accept(this);
       }
       public int forSplit(TreeD l, TreeD r) {
           return new Integer(((Integer)(l.accept(this))).intValue()
                              +
                              ((Integer)(r.accept(this))).intValue());
       }
   }

Like Father, Like Son
=====================
这一章节主要讲到了继承，从章节题目也可以看出来: 父子。

----------------------------------------

上一章节的最后表明了一个问题：
::

   由于自定义类型不支持运算，只能Java的内置类型有运算功能，

   所以在进行运算时，需要先转换成内置类型然后运算完后，

   再转换成特定的类型。

为了解决这个问题，就需要定义自定义类型的相关操作方法了。 

先实现数值类型的运算操作。

.. code-block:: java

   interface ExprVisitorI {
       Object forPlus(ExprD l, ExprD r); // 相加
       Object forDiff(ExprD l, ExprD r); // 相减
       Object forProd(ExprD l, ExprD r); // 相乘
       Object forConst(Object c); // 常量
   }

   abstract class ExprD {
       abstract Object accept(ExprVisitorI ask);
   }

   class Plus extends ExprD {
       ExprD l;
       ExprD r;
       Plus(ExprD _l, ExprD _r) {
           l = _l;
           r = _r;
       }
       Object accept(ExprVisitorI ask){
           return ask.forPlus(l, r);
       }
   }

   class Diff extends ExprD {
       ExprD l;
       ExprD r;
       Diff(ExprD _l, ExprD _r) {
           l = _l;
           r = _r;
       }
       Object accept(ExprVisitorI ask){
           return ask.forDiff(l, r);
       }
   }

   class Prod extends ExprD {
       ExprD l;
       ExprD r;
       Prod(ExprD _l, ExprD _r) {
           l = _l;
           r = _r;
       }
       Object accept(ExprVisitorI ask){
           return ask.forProd(l, r);
       }
   }

   class Const extends ExprD {
       Object c;
       Const(Object _c){
           c = _c;
       }
       Object accept(ExprVisitorI ask){
           return ask.forConst(c);
       }
   }

.. code-block:: java

   class IntEvalV implements ExprVisitorI {
       public Object forPlus(ExprD l, ExprD r){
           return plus(l.accept(this), r.accept(this));
       }
       public Object forDiff(ExprD l, ExprD r){
           return diff(l.accept(this), r.accept(this));
       }
       public Object forProd(ExprD l, ExprD r){
           return prod(l.accept(this), r.accept(this));
       }
       public Object forConst(Object c){
           return c;
       }
       Object plus(Object l, Object r){
           return new Integer(((Integer)l).intValue()
                              +
                              ((Integer)r).intValue());
       }
       Object diff(Object l, Object r){
           return new Integer(((Integer)l).intValue()
                              -
                              ((Integer)r).intValue());
       }
       Object prod(Object l, Object r){
           return new Integer(((Integer)l).intValue()
                              *
                              ((Integer)r).intValue());
       }       
   }

再实现，Set（集合）类型的运算操作。

.. code-block:: java

   abstract class SetD {
       SetD add(Integer i){
           if (mem(i))
               return this;
           else
               return new Add(i, this);
       }
       abstract boolean mem(Integer i);
       abstract SetD plus(SetD s);
       abstract SetD diff(SetD s);
       abstract SetD prod(SetD s);
   }

   class Empty extends SetD {
       boolean mem(Integer i){
           return false;
       }
       SetD plus(SetD s){
           return s;
       }
       SetD diff(SetD s){
           return new Empty();
       }
       SetD prod(SetD s){
           return new Empty();
       }
   }

   class Add extends SetD {
       Integer i;
       SetD s;
       Add(Integer _i, SetD _s){
           i = _i;
           s = _s;
       }
       boolean mem(Integer n){
           if (i.equals(n))
               return true;
           else
               return s.mem(n);
       }
       SetD plus(SetD t){
           return s.plus(t.add(i));
       }
       SetD diff(SetD t){
           if (t.mem(i))
               return s.diff(t);
           else
               return s.diff(t).add(i);
       }
       SetD prod(SetD t){
           if (t.mem(i))
               return s.prod(t).add(i);
           else
               return s.prod(t);
       }
   }

   class SetEvalV extends IntEvalV {
       Object plus(Object l, Object r){
           return ((SetD)l).plus((SetD)r);
       }
       Object diff(Object l, Object r){
           return ((SetD)l).diff((SetD)r);
       }
       Object prod(Object l, Object r){
           return ((SetD)l).prod((SetD)r);
       }
   }

`SetEvalV` 直接继承  `IntEvalV` 有点不合理，好，我们改一下。

再抽象一个基类出来，将两者的公共代码放在基类里，然后让两者继承该基类。

.. code-block:: java

   abstract class EvalD implements ExprVisitorI {
       public Object forPlus(ExprD l, ExprD r){
           return plus(l.accept(this), r.accept(this));
       }
       public Object forDiff(ExprD l, ExprD r){
           return diff(l.accept(this), r.accept(this));
       }
       public Object forProd(ExprD l, ExprD r){
           return prod(l.accept(this), r.accept(this));
       }
       public Object forConst(Object c){
           return c;
       }
       abstract Object plus(Object l, Object r);
       abstract Object diff(Object l, Object r);
       abstract Object prod(Object l, Object r);
   }

   class IntEvalV extends EvalD {
       Object plus(Object l, Object r){
           return new Integer(((Integer)l).intValue()
                              +
                              ((Integer)r).intValue());
       }
       Object diff(Object l, Object r){
           return new Integer(((Integer)l).intValue()
                              -
                              ((Integer)r).intValue());
       }
       Object prod(Object l, Object r){
           return new Integer(((Integer)l).intValue()
                              *
                              ((Integer)r).intValue());
       }                 
   }

   class SetEvalV extends EvalD {
       Object plus(Object l, Object r){
           return ((SetD)l).plus((SetD)r);
       }
       Object diff(Object l, Object r){
           return ((SetD)l).diff((SetD)r);
       }
       Object prod(Object l, Object r){
           return ((SetD)l).prod((SetD)r);
       }
   }

还记得第6章的 `SubstV` 和 `LtdSubstV` 么？

它们有很多相似的地方，能否采用上面的办法，合并起来？

.. code-block:: java

   abstract class SubstD implements PieVisitorI {
       Object n;
       Object o;
       SubstD(Object _n, Object _o) {
           n = _n;
           o = _o;
       }
       public PieD forBot() {
           return new Bot();
       }
       public abstract PieD forTop(Object t, PieD r);
   }

   class SubstV extends SubstD {
       SbustV(Object _n, Object _o) {
           super(_n, _o);
       }
       public PieD forTop(Object t, PieD r) {
           if (o.equals(t))
               return new Top(n, r.accept(this));
           else
               return new Top(t, r.accept(this));
       }
   }

   class LtdSubstV extends SubstD {
       int c;
       LtdSubstV(int _c, Object _n, Object _o) {
           super(_n, _o);
           c = _c;
       }
       public PieD forTop(Object t, PieD r) {
           if (c == 0)
               return new Top(t, r);
           else
               if (o.equals(t))
                   return new Top(n, r.accept(LtdSubstV(c-1, n, o)));
               else
                   return new Top(t, r.accept(this));           
       }
   }

.. tip::

   **第八条建议**

   When extending a class, use overriding

   to enrich its functionality.

根据以上建议， `LtdSubstV` 可以直接在 `SubstV` 类上进行继承和扩展。

.. code-block:: java

   class SbustV implements PieVisitorI {
       Object n;
       Object o;
       SubstV(Object _n, Object _o) {
           n = _n;
           o = _o;
       }
       public PieD forBot() {
           return new Bot();
       }
       public PieD fotTop(Object t, PieD r) {
           if (o.equals(t))
               return new Top(n, r.accept(this));
           else
               return new Top(t, r.accept(this));
       }
   }

   class LtdSubstV extends SubstV {
       int c;
       Object n;
       Object o;
       LtdSubstV(int _c, Object _n, Object _o) {
           super(_n, _o);
           c = _c;
       }
       public PieD forTop(Object t, PieD r) {
           if (c == 0)
               return new Top(t, r);
           else
               if (o.equals(t))
                   return new Top(n, r.accept(LtdSubstV(c-1, n, o)));
               else
                   return new Top(t, r.accept(this));
       }
   }
   
Be a Good Visitor
=================
先引入 `super` 关键字。

.. code-block:: java

   class ShadowedCartesianPt extend CartesianPt {
       int tx;
       int ty;
       ShadowedCartesianPt(int _x, int _y, int _tx, int _ty) {
           super(_x, _y);
           tx = _tx;
           ty = _ty;
       }
       int distanceTo0() {
           return super.distanceTo0()
                  +
                  (int)Math.sqrt(tx * tx + ty * ty);
       }
   }


.. code-block:: java

   interface ShapeVisitorI {
       boolean forCircle(int r);
       boolean forSquare(int s);
       boolean forTrans(PointD q, ShapeD s);
   }

   abstract class ShapeD {
       abstract boolean accept(ShapeVisitorI ask);
   }

   class Circle extend ShapeD { // 圆心在坐标原点的圆
       int r;
       Circle(int _r) {
           r = _r;
       }
       boolean accept(ShapeVisitorI ask) {
           return ask.forCircle(r);
       }
   }

   class Square extend ShapeD { //左上角在坐标原点的正方形
       int r;
       Square(int _r) {
           r = _r;
       }
       boolean accept(ShapeVisitorI ask) {
           return ask.forSquare(r);
       }
   }
   
   class Trans extend ShapeD { //在指定位置的图形，
       PointD q;
       ShapeD s;
       Trans(PointD _q, ShapeD _s) {
           q = _q;
           s = _s;
       }
       boolean accept(ShapeVisitorI ask) {
           return ask.forTrans(q, s);
       }
   }

.. code-block:: java

   // 检查某个点是否在图形内部
   class HasPtV implements ShapeVisitorI {
       PointD p;
       HasPtV(PointD _p) {
           p = _p;
       }
       public boolean forCircle(int r) {
           return p.distanceTo0() <= r;
       }
       public boolean forSquare(int s) {
           return p.x <= s && p.y <= s;
       }
       public boolean forTrans(PointD q, ShapeD s) {
           return s.accept(new HasPtV(p.minus(q)));
       }
   }

书中说下面精彩的地方到了。

主要就是揭示了 `interface` 也能够被继承扩展，

和访问者模式的精华所在：兼有灵活性及扩展性。

.. code-block:: java

   class Union extends ShapeD {
       ShapeD s;
       ShapeD t;
       Union(ShapeD _s, ShapeD _t) {
           s = _s;
           t = _t;
       }
       boolean accept(ShapeVisitorI ask) {
           ((UnionVisitorI)ask).forUnion(s, t);
       }
   }

   interface UnionVisitorI extends ShapeVisitorI {
       boolean forUnion(ShapeD s, ShapeD t);
   }

   class UnionHasPtV extends HasPtV implements ShapeVisitorI {
       UnionHasPtV(PointD _p) {
           super(_p);
       }
       public boolean forUnion(ShapeD s, ShapeD t) {
           return s.accept(this) || t.accept(this);
       }
   }

.. code-block:: java

   class HasPtV implements ShapeVisitorI {
       PointD p;
       HasPtV(PointD _p) {
           p = _p;
       }
       ShapeVisitorI newHasPt(PointD p) {
           return new HasPtV(p);
       }
       public boolean forCircle(int r) {
           return p.distanceTo0() <= r;
       }
       public boolean forSquare(int s) {
           return p.x <= s && p.y <= s;
       }
       public boolean forTrans(PointD q, ShapeD s) {
           return s.accept(newHasPtV(p.minus(q)));
       }
   }

.. tip::
  
   **第九条建议**

   If a datatype may have to be extended,

   be forward looking and use a

   constructor-like(override) method

   so that visitors can be extended too.

正是由于上面的提取出了 `newHasPt` 方法，下面直接重载即可。

.. code-block:: python

   class UnionHasPtV extends HasPtV implements UnionVisitorI {
       UnionHasPtV(PointD _p) {
           super(_p);
       }
       ShapeVisitorI newHasPt(PointD p) {
           return new UnionHasPtV(p);
       }
       public boolean forUnion(ShapeD s, ShapeD t) {
           return s.accept(this) || t.accept(this);
       }
   }

The State of Things to Come
===========================

之前的章节每次都是生成新的实例，然后再对该实例进行操作。

这一章节主要讲到如果修改实例中的属性，然后再进行操作。

----------------------------------------

.. code-block:: java

   interface PiemanI {
       int addTop(Object t);
       int remTop(Object t);
       int substTop(Object n, Object o);
       int occTop(Object o);
   }

   class PiemanM implements PiemanI {
       PieD p = new Bot();
       public int addTop(Object t) {
           p = new Top(t, p);
           return occTop(t);
       }
       public int remTop(Object t) {
           p = (PieD)p.accept(new RemV(t));
           return occTop(t);
       }
       public int substTop(Object n, Object o) {
           p = (PieD)p.accept(new SubstV(n o));
           return occTop(n);
       }
       public int occTop(Object o) {
           return ((Integer)p.accept(new OccursV(o))).intValue();
       }
   }

   interface PieVisitorI {
       Object forBot();
       Object forTop(Object t, PieD r);
   }

   abstract class PieD {
       abstract Object accept(PieVisitorI ask);
   }

   class Bot extends PieD {
       Object accept(PieVisitorI ask) {
           return ask.forBot();
       }
   }

   class Top extends PieD {
       Object t;
       PieD r;
       Top(Object _t, Object _r) {
           t = _t;
           r = _r;
       }
       Object accept(PieVisitorI ask) {
           return ask.forTop(t, r);
       }
   }

   class OccursV implements PieVisitorI {
       Object a;
       OccursV(Object _a) {
           a = _a;
       }
       public Object forBot() {
           return new Integer(0);
       }
       public Object forTop(Object t, PieD r) {
           if (t.equals(a))
               return new Integer(((Integer)(r.accept(this))).intValue() + 1);
           else
               return r.accept(this);
       }
   }

   class SubstV implements PieVisitorI {
       Object n;
       Object o;
       SubstV(Object _n, Object _o) {
           n = _n;
           o = _o;
       }
       public Object forBot() {
           return new Bot();
       }
       public Object forTop(Object t, PieD r) {
           if (o.equals(t))
               return new Top(n, (PieD)r.accept(this));
           else
               return new Top(t, (PieD)r.accept(this));
       }
   }

   class RemV implements PieVisitorI {
       Object o;
       RemV(Object _o) {
           o = _o;
       }
       public Object forBot() {
           return new Bot();
       }
       public Object forTop(Object t, PieD r) {
           if (o.equals(t))
               return r.accept(this);
           else
               return new Top(t, (PieD)r.accept(this));
       }
   }

.. code-block:: java

   interface PieVisitorI {
       Object forBot(Bot that);
       Object forTop(Top that);
   }

   abstract class PieD {
       abstract Object accept(PieVisitorI ask);
   }

   class Bot extends PieD {
       Object accept(PieVisitorI ask) {
           return ask.forBot(this);
       }
   }

   class Top extends PieD {
       Object t;
       PieD r;
       Top(Object _t, Object _r) {
           t = _t;
           r = _r;
       }
       Object accept(PieVisitorI ask) {
           return ask.forTop(this);
       }
   }
   
   class OccursV implements PieVisitorI {
       Object a;
       OccursV(Object _a) {
           a = _a;
       }
       public Object forBot(Bot that) {
           return new Integer(0);
       }
       public Object forTop(Top that) {
           if (that.t.equals(a))
               return new Integer(((Integer)(that.r.accept(this))).intValue() + 1);
           else
               return that.r.accept(this);
       }
   }

   class SubstV implements PieVisitorI {
       Object n;
       Object o;
       SubstV(Object _n, Object _o) {
           n = _n;
           o = _o;
       }
       public Object forBot(Bot that) {
           return new Bot();
       }
       public Object forTop(Top that) {
           if (o.equals(that.t))
               return new Top(n, (PieD)(that.r).accept(this));
           else
               return new Top(that.t, (PieD)(that.r).accept(this));
       }
   }

   class RemV implements PieVisitorI {
       Object o;
       RemV(Object _o) {
           o = _o;
       }
       public Object forBot(Bot that) {
           return new Bot();
       }
       public Object forTop(Top that) {
           if (o.equals(that.t))
               return that.r.accept(this);
           else
               return new Top(that.t, (PieD)(that.r).accept(this));
       }
   }

接下来，咱们通过彻底地修改实例的属性，而不是重新生成新的实例，来实现一个访问者。

.. code-block:: java

   class SubstV implements PieVisitorI {
       Object n;
       Object o;
       SubstV(Object _n, Object _o) {
           n = _n;
           o = _o;
       }
       public Object forBot(Bot that) {
           return that;
       }
       public Object forTop(Top that) {
           if (o.equals(that.t))
               that.t = n;
               that.r.accept(this);
               return that;
           else
               that.r.accept(this);
               return that;
       }
   }

.. tip::

   **第十条建议**

   当必须修改一个对象时，使用一个类来隐藏修改操作，

   否则它就会对你的整个流程造成影响。

咱们再一个例子，加深一下理解。

.. code-block:: java

   abstract class PointD{
       int x;
       int y;
       PointD(int _x, int _y){
           x = _x;
           y = _y;
       }
       boolean closerTo0(PointD p) {
           return distanceTo0() <= p.distanceTo0();
       }
       PointD minus(PointD p) {
           return CartesianPt(x - p.x, y - p.y);
       }
       int moveBy(int tx, int ty) {
           x = x + tx;
           y = y + ty;
           return distanceTo0();
       }
       abstract int distanceTo0();
   }

   class CartesianPt extends PointD{ //笛卡尔坐标
       CartesianPt(int _x, int _y){
           super(_x, _y);
       }
       int distanceTo0(){
           return (int)Math.sqrt(x * x + y * y);
       }
   }

   class ManhattanPt extends PointD{ //曼哈顿坐标
       ManhattanPt(int _x, int _y){
           super(_x, _y);
       }
       int distanceTo0(){
           return x + y;
       }
   }
   
   class ShadowedManhattanPt extends ManhattanPt{ //曼哈顿坐标
       int tx;
       int ty;
       ManhattanPt(int _x, int _y, int _tx, int _ty){
           super(_x, _y);
           tx = _tx;
           ty = _ty;
       }
       int distanceTo0(){
           return super.distanceTo0() + tx + ty; 
       }
   }

.. _`Church encoding`: http://en.wikipedia.org/wiki/Church_encoding
